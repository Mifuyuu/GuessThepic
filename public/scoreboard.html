<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GuessThepic</title>
    <link rel="icon" href="imgs/guessthepic-icon.png" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Prompt:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap');
        /* --- Basic Reset & Body --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', 'Prompt', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            /* min-height: 100vh; */
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        /* --- Main Container --- */
        #scoreboard-container {
            width: 100%;
            max-width: 600px;
            text-align: center;
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .lb-header-section {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            color: #721ae6;
            h2 {
                font-size: 1.8rem;
                font-weight: 700;
            }
        }

        /* --- Controls --- */
        #sort-controls {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 25px;
             gap: 15px;
        }

        #sort-controls label {
            font-weight: 500;
            color: #555;
        }

        #sort-by {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 1rem;
            flex-grow: 1;
            background-color: #fff;
            cursor: pointer;
        }

        /* --- Leaderboard Area --- */
        #leaderboard {
            position: relative; /* Crucial for absolute positioning of rows */
            height: calc((var(--team-height, 55px) + var(--team-spacing, 8px)) * 10 + 55px); /* Adjust height based on row height/spacing + maybe one extra for user */
            width: 100%;
            margin-bottom: 20px;
            /* overflow: hidden; */
        }

        /* --- Individual Scoreboard Row --- */
        :root {
            --team-height: 55px;
            --team-spacing: 8px;
        }

        .scoreboard-row {
            position: absolute; /* Needed for position animation */
            width: 100%;
            height: var(--team-height);
            background: var(--color, #607d8b); /* Default color, overridden by rank */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            left: 0;
            /* --- The Magic: Position based on --i and Animate 'top' --- */
            top: calc(var(--i, 0) * (var(--team-height) + var(--team-spacing)));
            transition: top 500ms cubic-bezier(0.68, -0.55, 0.265, 1.55), /* Animate position */
                        opacity 300ms ease-out,                         /* Animate fade in/out */
                        background-color 300ms ease;                   /* Animate color change */
            /* --- End Magic --- */
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 8px;
            padding: 0 20px;
            color: #fff;
            font-weight: 500;
            opacity: 1; /* Default visible state */
        }

        /* Style for when a row is being removed (optional fade-out) */
        .scoreboard-row.removing {
            opacity: 0; /* Fade out */

        }

        /* Style for user highlight */
        .scoreboard-row.user-highlight {
             /* border: 2px solid #ffeb3b; */
             outline: 3px solid #8400ff; /* Use outline instead of border */
             outline-offset: -2px; /* Adjust offset */
             box-shadow: 0 0 10px rgba(134, 59, 255, 0.6);
        }

        .scoreboard-row span:first-child { /* Rank + Username */
            font-size: 1.05rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }

        .scoreboard-row span:last-child { /* Score/Streak */
            font-size: 1.2rem;
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }

        /* --- Status Messages (Loading/Error/Empty) --- */
        .status-message {
            position: absolute;
            top: 40%; /* Adjust vertical position */
            left: 50%;
            transform: translate(-50%, -50%);
            font-style: italic;
            color: #777;
            font-size: 1rem;
            padding: 20px;
            text-align: center;
            width: 80%; /* Ensure it doesn't get too wide */
        }
        .status-error { color: #e53935; }
        .status-warning { color: #f9a825; }
        .status-info { color: #555; }

        /* --- User Rank Display (Separate Div) --- */
        #user-rank {
            margin-top: 20px;
            font-weight: 600;
            background-color: #e8eaf6;
            color: #3f51b5;
            padding: 12px 18px;
            border-radius: 8px;
            border: 1px solid #c5cae9;
            text-align: center;
        }
        #user-rank-text { color: #1a237e; }

        /* --- Back Button --- */
        #back-to-game {
            margin-top: 25px;
            padding: 12px 25px;
            background: linear-gradient(45deg, #42a5f5, #1e88e5);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        #back-to-game:hover {
            background: linear-gradient(45deg, #1e88e5, #1565c0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        #back-to-game:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* --- Rank Colors Default --- */
        .rank-1 { --color: #ffc107; color: #424242;}
        .rank-2 { --color: #e0e0e0; color: #424242;}
        .rank-3 { --color: #d8a477; }
        .rank-4 { --color: #81c784; }
        .rank-5 { --color: #64b5f6; }
        .rank-6 { --color: #ffb74d; }
        .rank-7 { --color: #e57373; }
        .rank-8 { --color: #9575cd; }
        .rank-9 { --color: #78909c; }
        .rank-10 { --color: #4dd0e1; }
        .user-rank-outside { --color: #7e57c2; }

        /* --- Rank Colors Custom--- */
        .rank-1 { --color: #ffd34d; color: #424242;} /* Gold */
        .rank-2 { --color: #e0e0e0; color: #424242;} /* Silver */
        .rank-3 { --color: #d8a477; } /* Bronze */
        .rank-4, .rank-5, .rank-6, .rank-7, .rank-8, .rank-9, .rank-10 { --color: #3a3a3a; } /* Green */
        .user-rank-outside { --color: #7e57c2; } /* Specific color for user outside top 10 */
    </style>
</head>
<body>
    <div id="scoreboard-container">
        <div class="lb-header-section">
            <i class="fa-solid fa-trophy fa-2x"></i>
            <h1>Leaderboard</h1>
        </div>

        <div id="sort-controls">
            <label for="sort-by">Sort By:</label>
            <select id="sort-by">
                <option value="score">Score</option>
                <option value="mostStreak">Highest Streak</option>
            </select>
        </div>

        <div id="leaderboard">
            <p class="status-message" id="status-message" style="display:none;">Loading...</p>
        </div>

        <div id="user-rank" style="display:none;">
        </div>

        <button id="back-to-game">Back to Game</button>
    </div>

    <script>
        // --- DOM Element References ---
        const sortBySelect = document.getElementById('sort-by');
        const leaderboardDiv = document.getElementById('leaderboard');
        const userRankDiv = document.getElementById('user-rank');
        const statusMessage = document.getElementById('status-message');
        const backToGameButton = document.getElementById('back-to-game');

        // --- State Variables ---
        let playerElements = new Map(); // Map: username -> { element: HTMLElement, data: Object, currentRank: number }
        let currentUsername = sessionStorage.getItem('username');
        const token = localStorage.getItem('token'); // Assuming you are back to using localStorage for token
        let isFetchingLeaderboard = false; // Flag to prevent race conditions

        // --- Socket.IO Client Setup ---
        const socket = io({ /* auth: { token: token } // Optional: Add if server verifies sockets */ });

        socket.on('connect', () => {
            console.log('Socket.IO Connected:', socket.id);
        });

        socket.on('scoreUpdated', () => {
            console.log('Received "scoreUpdated" event.');
            // *** เรียกใช้ fetch แบบมีตัวป้องกัน ***
            requestLeaderboardUpdate();
        });

        socket.on('disconnect', (reason) => {
            console.warn('Socket.IO Disconnected. Reason:', reason);
            setStatusMessage('Real-time updates disconnected.', 'warning');
        });

        socket.on('connect_error', (error) => {
            console.error('Socket.IO Connection Error:', error);
            setStatusMessage(`Connection error: ${error.message}. Real-time updates unavailable.`, 'error');
        });
        // --- End Socket.IO Setup ---

        // --- Helper Functions ---
        function setStatusMessage(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`; // Set class for styling
            statusMessage.style.display = 'block';
            // Hide individual elements if showing a status message covering the area
             leaderboardDiv.querySelectorAll('.scoreboard-row').forEach(el => el.style.opacity = '0'); // Hide rows visually
             userRankDiv.style.display = 'none';
        }

        function formatRank(rank) {
            if (!rank) return '';
            if (rank === 1) return "1st";
            if (rank === 2) return "2nd";
            if (rank === 3) return "3rd";
            // Add specific handling for 11th, 12th, 13th if needed, otherwise 'th' is generally ok
            const lastDigit = rank % 10;
            const lastTwoDigits = rank % 100;
            if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
                return `${rank}th`;
            }
            switch (lastDigit) {
                case 1: return `${rank}st`;
                case 2: return `${rank}nd`;
                case 3: return `${rank}rd`;
                default: return `${rank}th`;
            }
        }

        // Helper Function to Clear Data and Redirect (if using localStorage token)
        function clearAuthDataAndRedirect() {
            localStorage.removeItem('token');
            sessionStorage.removeItem('username');
            window.location.href = 'index.html';
        }
        // --- End Helper Functions ---

        // --- Function to request update (with debounce/guard) ---
        function requestLeaderboardUpdate() {
            if (isFetchingLeaderboard) {
                console.log("Already fetching leaderboard, skipping duplicate request.");
                return; // If already fetching, do nothing
            }
            // Set flag immediately before calling fetch
            isFetchingLeaderboard = true;
            fetchLeaderboard(sortBySelect.value)
              .catch(err => {
                  // Log errors that bubble up from fetchLeaderboard
                  console.error("Error caught after fetchLeaderboard finished:", err);
              })
              .finally(() => {
                  // *** Clear Flag when Fetch is completely done (success or fail) ***
                  isFetchingLeaderboard = false;
                  console.log("Fetch process complete, flag reset.");
              });
        }


        // --- Event Listeners ---
        backToGameButton.addEventListener('click', () => {
            window.location.href = 'game.html';
        });

        sortBySelect.addEventListener('change', () => {
            console.log(`Sort changed to: ${sortBySelect.value}`);
            // When sort changes, request a new fetch
            requestLeaderboardUpdate();
        });
        // --- End Event Listeners ---

        // --- Core Function: Fetch and Update Leaderboard ---
        async function fetchLeaderboard(sortBy = 'score') {
            console.log(`Attempting to fetch leaderboard with sortBy = "${sortBy}"`);

            // Re-check auth state just before fetching
            currentUsername = sessionStorage.getItem('username'); // Get latest username
            const currentToken = localStorage.getItem('token'); // Get latest token

            if (!currentToken || !currentUsername) {
                console.error('Auth missing before fetch. Redirecting.');
                clearAuthDataAndRedirect(); // Use helper to clear and redirect
                throw new Error("Authentication missing"); // Throw error to stop execution here
            }

            setStatusMessage('Loading leaderboard...', 'info');

            // NOTE: The try/catch block handles errors within the async function.
            // The .catch().finally() in requestLeaderboardUpdate handles errors *after* this function resolves/rejects.
            try {
                const response = await fetch(`/api/leaderboard?sortBy=${sortBy}`, {
                     headers: { 'Authorization': `Bearer ${currentToken}` } // Use currentToken
                 });

                 // Handle Auth errors first
                 if (response.status === 401 || response.status === 403) {
                      const responseText = await response.text();
                      console.error(`Authentication Error (${response.status}) fetching leaderboard: ${responseText}. Redirecting...`);
                      clearAuthDataAndRedirect(); // Use helper
                      throw new Error("Authentication failed"); // Throw to stop execution
                 }

                if (!response.ok) {
                     setStatusMessage(`Error loading leaderboard: ${response.status} ${response.statusText}`, 'error');
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }

                const data = await response.json();
                statusMessage.style.display = 'none'; // Hide loading message
                leaderboardDiv.querySelectorAll('.scoreboard-row').forEach(el => el.style.opacity = '1'); // Ensure rows are visible again

                if (!data || !Array.isArray(data.leaderboard)) {
                    console.error("Invalid data format received:", data);
                    setStatusMessage("Failed to process leaderboard data.", 'error');
                    throw new Error("Invalid data format"); // Throw to stop execution
                }

                // --- DOM Update Logic ---
                console.log("Received new leaderboard data:", data); // Log the whole data object received
                const newLeaderboardData = data.leaderboard;
                const currentUserRankData = {
                     rank: data.userRank,
                     score: data.userScore,
                     mostStreak: data.userMostStreak
                };

                const newUsernamesInTop = new Set(newLeaderboardData.map(p => p.username));
                const nextPlayerElements = new Map();

                // 1. Update or Create elements
                newLeaderboardData.forEach((playerData, index) => {
                    const username = playerData.username || 'Unknown';
                    // *** Ensure value calculation uses the current sortBy parameter ***
                    const value = sortBy === 'score' ? (playerData.score ?? 0) : (playerData.mostStreak ?? 0);
                    const rank = index + 1;
                    console.log(`Processing Rank ${rank}: ${username} - Value to display (${sortBy}): ${value}`);

                    let existingEntry = playerElements.get(username);
                    let playerDiv;
                    

                    if (existingEntry) {
                        // --- UPDATE EXISTING ---
                        playerDiv = existingEntry.element;
                        console.log(` -> Found existing element for ${username}.`);

                        // *** Force Update Text Content ***
                        const nameSpan = playerDiv.querySelector('span:first-child');
                        const valueSpan = playerDiv.querySelector('span:last-child');
                        if (nameSpan) nameSpan.textContent = `${rank}. ${username}`;
                        else console.warn(` -> !! Could not find name span for ${username}`);

                        if (valueSpan) {
                            console.log(` -> Updating value SPAN for ${username} to ${value}`);
                            valueSpan.textContent = value; // Set new value
                        } else console.warn(` -> !! Could not find value span for ${username}`);

                        // Update position via CSS variable
                        playerDiv.style.setProperty('--i', index);

                        // Update rank class for styling
                        const newRankClass = `rank-${rank}`;
                        if (!playerDiv.classList.contains(newRankClass)) {
                             console.log(` -> Updating rank class for ${username} to ${newRankClass}`);
                             playerDiv.className = playerDiv.className.replace(/rank-\d+/g, '').trim();
                             playerDiv.classList.add('scoreboard-row', newRankClass);
                        }

                        // Update highlight status
                        if (username === currentUsername) playerDiv.classList.add('user-highlight');
                        else playerDiv.classList.remove('user-highlight');

                        playerElements.delete(username); // Mark as processed from old map

                    } else {
                        // --- CREATE NEW ---
                        console.log(` -> Creating new element for ${username}`);
                        playerDiv = document.createElement('div');
                        playerDiv.className = `scoreboard-row rank-${rank}`;
                         if (username === currentUsername) playerDiv.classList.add('user-highlight');
                        playerDiv.style.setProperty('--i', index);
                        playerDiv.innerHTML = `
                            <span>${rank}. ${username}</span>
                            <span>${value}</span>
                        `;
                        leaderboardDiv.appendChild(playerDiv);
                         // Optional: Entry animation trigger
                         // playerDiv.style.opacity = '0';
                         // requestAnimationFrame(() => { playerDiv.style.opacity = '1'; });
                    }

                    // Add to the next state map
                     nextPlayerElements.set(username, { element: playerDiv, data: playerData, currentRank: rank });
                });

                // 2. Remove elements no longer in the Top list
                playerElements.forEach((entryToRemove, username) => {
                    console.log(` -> Removing element for ${username} (dropped off top list)`);
                    const element = entryToRemove.element;
                    element.classList.add('removing'); // Add class for potential exit animation
                    setTimeout(() => {
                         // Double check before removing, in case things changed rapidly
                         if (element.parentNode === leaderboardDiv && !nextPlayerElements.has(username)) {
                              leaderboardDiv.removeChild(element);
                         } else {
                              console.log(` -> Skipping removal for ${username}, already removed or re-added.`);
                         }
                    }, 500); // Match CSS transition or adjust
                });

                // 3. Update the main state map
                playerElements = nextPlayerElements;
                console.log("Updated playerElements Map size:", playerElements.size);

                // 4. Update User Rank Display (separate div)
                 if (currentUserRankData.rank !== null && currentUserRankData.rank !== undefined) {
                     // *** Ensure value calculation uses the current sortBy parameter ***
                     const userValue = sortBy === 'score' ? (currentUserRankData.score ?? 0) : (currentUserRankData.mostStreak ?? 0);
                     const rankString = formatRank(currentUserRankData.rank);
                     userRankDiv.innerHTML = `Your Rank: <span id="user-rank-text">${rankString} (${sortBy === 'score' ? 'Score' : 'Streak'}: ${userValue})</span>`; // Show sort type
                     userRankDiv.style.display = 'block';
                 } else {
                     userRankDiv.style.display = 'none';
                 }

                 // 5. Handle the special row for user outside top 10
                 handleUserOutsideTop10(currentUserRankData, newUsernamesInTop, sortBy);


                // Handle empty state AFTER processing
                if (playerElements.size === 0 && !currentUserRankData.rank) {
                    setStatusMessage("No players on the leaderboard yet.", 'info');
                }

            } catch (error) {
                // Errors thrown from within the try block (Auth, HTTP, Data format, etc.)
                console.error('Caught error during fetchLeaderboard execution:', error);
                // Avoid setting status message if auth redirect already happened
                if (!error.message.includes("Authentication")) {
                     setStatusMessage('Could not load leaderboard.', 'error');
                }
                // Re-throw the error so the .catch() in requestLeaderboardUpdate sees it
                throw error;
            }
            // The 'finally' block in requestLeaderboardUpdate will handle resetting the flag
        }

        // Helper function specifically for the user outside top 10 row
        function handleUserOutsideTop10(userData, topUsernames, sortBy) { // Ensure sortBy is passed
             const userRowOutsideId = 'user-rank-outside-row';
             let userRowOutside = document.getElementById(userRowOutsideId);
             const shouldShowOutside = userData.rank !== null && userData.rank > 10 && !topUsernames.has(currentUsername);

             if (shouldShowOutside) {
                 // *** Ensure value calculation uses the current sortBy parameter ***
                 const userValue = sortBy === 'score' ? (userData.score ?? 0) : (userData.mostStreak ?? 0);
                 const rankString = formatRank(userData.rank); // Use formatRank

                 if (!userRowOutside) { // Create if doesn't exist
                     userRowOutside = document.createElement('div');
                     userRowOutside.id = userRowOutsideId;
                     userRowOutside.className = 'scoreboard-row user-rank-outside';
                     userRowOutside.style.setProperty('--i', 10); // Fixed position
                     leaderboardDiv.appendChild(userRowOutside);
                 }
                 // Update content
                 userRowOutside.innerHTML = `
                      <span>${userData.rank}. ${currentUsername}</span>
                      <span>${userValue}</span> <!-- Display correct value -->
                 `;

             } else if (userRowOutside) { // Remove if exists but shouldn't be shown
                  userRowOutside.remove();
             }
        }


        // --- Initial Load ---
        window.addEventListener('load', () => {
            // Check auth state on load
            currentUsername = sessionStorage.getItem('username');
            const currentToken = localStorage.getItem('token');
            if (currentToken && currentUsername) {
                requestLeaderboardUpdate(); // Use the guarded request function for initial load too
            } else {
                console.log('Auth missing on load. Redirecting.');
                // No need to call clearAuthDataAndRedirect here, just redirect
                window.location.href = 'index.html';
            }
        });
    </script>
</body>
</html>